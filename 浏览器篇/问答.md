## 仅仅打开了一个页面，为什么有四个进程？
* 线程和进程的关系
    > 多线程可以并行处理任务，不能单独存在  线程由进程启动和管理 进程就是每个程序的实例  
* 线程和进程的关系
    > 进程中任何一个线程报错都会导致进程崩溃  线程可以共享进程的数据   进程关闭后，操作系统会回收进程所占用的内存   进程之间的内容相互隔离
* 单进程浏览器 
    > 1. 不稳定 单进程中的插件、渲染线程崩溃都会导致浏览器挂掉 
      2. 不流畅， 脚本（死循环） 或插件会导致浏览器卡顿
      3. 不安全， 插件和脚本可以获得操作系统任意资源
* 多进程浏览器
    > 1. 解决不稳定， 进程之间相互隔离，一个页面或者插件崩溃时 仅仅影响当前页面或者插件 不会影响其他页面 
      2. 解决不流畅   脚本阻塞当前页面渲染进程，不会影响到其他页面
      3. 解决不安全   采用多进程架构使用沙箱 （沙箱可以看成是操作系统给进程上的一把锁）沙箱的程序可以运行， 但是不能写入数据， 也不能在敏感位置读取任何数据
* 多进程架构
    > 分为浏览器进程 渲染进程 GPU进程，插件进程，网络进程

缺点：资源占用高，体系架构复杂

面向服务架构：把原来的各种模块重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务必须使用定义好的接口，通过 IPC 通讯，使得系统更内聚、松耦合、易维护和拓展。


* TCP协议：如何保证页面文件能够完成送达?
    > 1. ip头是ip数据包开头的信息 包括 ip版本 源ip地址 目标ip地址 生存时间等信息
      2. UDP头中除了有目的端口 还有源端口号等信息
      3. ip负责把 数据送达到目的主机
      4. UDP负责把数据送达具体应用
      5. 对于错误的数据包，UDP不提供重发机制，只是丢弃当前包，不能保证数据的可靠性，但是传输速度快
      6. TCP除了包含目标端口和本地端口号外，还提供了用于排列的序列号，保证数据完整的传输，连接分为三个阶段： 建立连接， 传输数据， 断开连接

* HTTP请求流程： 为什么很多站点第二次打开会很快
    >  浏览器中的HTTP请求从发起到结束经历了八个阶段： 构建请求，查找缓存，准备IP和端口，等待TCP连接，建立TCP连接，发起HTTP请求，服务器处理请求，服务器返回数据和断开连接
    >> 1. 构建请求：浏览器构建请求行，构建好后，准备发起网络请求
       2. 查找缓存  在真正发起请求前浏览器会查询缓存中是否有请求资源副本，有则拦截请求，返回资源副本，否则进入网络请求
       3. 准备IP地址和端口号 HTTP网络请求需要和服务器建立TCP连接，建立TCP连接需要IP地址和端口号，浏览器需要请求DNS返回域名对应的IP，同时会缓存域名缓存结果，供下次查询使用
       4. 等待TCP队列 chrome机制 同一个域名连接下，同时最多只能有6个TCP连接
       5. 建立TCP连接，TCP通过三次握手建立连接，传输数据，通过四次挥手断开连接
       6. 发送 HTTP请求 建立TCP请求后，浏览器就可以和服务器进行HTTP数据传输了，首先会向服务器发起请求行，然后以请求头形式发送一些其他信息，如果是POST请求还会发送请求体
       7. 服务器处理请求 首先服务器会返回响应行 随后， 服务器向浏览器发送响应头和响应体，通常服务器返回数据，就会关闭TCP连接 如果请求头或者响应头中有 connection： keep-alive TCP保持打开状态

* 从输入URL到页面展示经历了什么？
    > 1. 用户输入URL并回车
      2. 浏览器检查URL，组装协议，构成完整的URL
      3. 浏览器进程通过进程通信（IPC）将URL请求发送给网络进程
      4. 网络进程收到URL请求后查找本地缓存是否缓存了该请求资源，如果有则直接将缓存返回给浏览器进程
      5. 如果没有则向WEB发起HTTP网络请求，请求流程如下：
        >> * 进行DNS解析获取服务器地址，端口
           * 利用IP和服务器建立TCP连接
           * 构建请求头信息
           * 发送请求头信息 
           * 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
      6. 网络进程解析响应流程： 
        >> * 检查状态码，如果是301/302 则需要重定向，从location读取地址，重新进行请求，如果是200则继续处理请求
           * 200响应处理，检查响应类型content-type 如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续渲染，如果是HTML则通知浏览器进程准备渲染进程进行渲染
      7. 准备渲染进程
        >> 浏览器进程检查当前URL是否和之前打开的渲染进程根域名是否相同，相同，则复用原来的进程，若不同，则开启新的渲染进程
      8. 传输数据 更新状态
        >> * 渲染进程准备好后， 浏览器向渲染进程发起 ‘提交文档’的消息，渲染进程接收到消息后和网络进程建立传输数据的管道
           * 渲染进程接收完数据后，向浏览器发送‘确认提交’
           * 浏览器进程接收到确认消息后， engine 浏览器界面状态，安全，地址URL，前进后退的历史状态，更新WEB页面
* HTML CSS JS是如何变成页面的？
    > 1. 浏览器进程不能直接理解 HTML数据，需要将其转化为DOM树结构
      2. 生成DOM树后，根据CSS样式表，计算出DOM树所有节点样式
      3. 创建布局树： 遍历DOM树所有可见节点， 把这些节点加入到布局中，不可见节点忽略，如（head中所有元素 display none 元素）
      4. 分层：层叠上下文属性的元素（定位属性元素、透明属性元素、CSS 滤镜属性元素）提升为单独一层，需要裁剪的地方（出现滚动条）也会被创建为图层
      